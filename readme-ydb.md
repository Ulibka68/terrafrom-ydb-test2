[Managed Disks](#улучшение-старой-системы-описания-таблиц)

# Создание базы 
Создайте serverless базу YDB согласно документации (используя terraform)

# Формирование ключа для доступа к YDB
В корневой директории необходимо сформировать ключ для доступа к базе.
Ключ будет сформирован в файле sa.json

Запустите команду: (если Вы под windows - то лучше запускать из wsl)
```
yc iam key create \
--folder-id <идентификатор каталога> \
--service-account-name <имя сервисного аккаунта> \
--output service_account_key_file.json
```

### yc
Про установку и настройку yc прочитайте тут:

https://cloud.yandex.ru/docs/cli/quickstart

## Создание конфигурационного файла 
Создайте файл env.local в корневой директории.  
Скопируйте туда строку:  
YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS=service_account_key_file.json  
(готовый пример файла уже приведен в данном проекте)

# Настройка подключения к базе данных
Перейдите в консоль YDB, создайте базу данных и сверху справа будет кнопка "подключиться".
![img](https://raw.githubusercontent.com/Ulibka68/terrafrom-ydb-test2/contrubute-to-sdk/assets/1.png)
Нажмите на нее и заполните в файле env.local поля:  
DOCUMENT_API_ENDPOINT и  
DATABASENAME

# Улучшение старой системы описания таблиц

Добавил два декоратора для описания обязательных и опциональных полей:  
declareTypePrim,  
declareTypeNull  

Добавил generic класс ITableFromClass для получения типа-интерфейса для испольования в методе create 

type ITMdb = ITableFromClass<Tmdb>;

Пример можно посмотреть в файле table_defs.ts

# Новая структура формирования описания таблиц 

В предыдущей версии SDK предлагалось писать доваольно много однотипного повторяющегося кода, не было инструментов, которые позволяли бы стандартным образом добавлять в таблицу одну или несколько записей.

Текушая реализация позволяет с легкостью выполнять все вышеперечисленные действия:

1. создать/удалить таблицу согласно сформированному описанию таблицы
2. добавить одну строку с данными в таблицу, возможность использования опциональных полей.
3. добавить несколько записей в таблицу (все непереданные поля автоматически устанавливаются в null)
4. В SDK добавлена реализация команды bulk upsert

## Детали реализации
Оригинальная версия SDK разработана с учетом сохранения метаинформации о типах данных с использованием Reflect.metadata для свойств класса. Такой способ реализации подразумевает под собой вызов декоратора каждый раз при создании экземпляра класса либо при назначении нового значения свойству.

Я решил метаданные, описывающие структуру таблицы хранить в static свойстве refMetaData, ссылающемся на объект. Такой подход позволят формировать метаданные только один раз перед использованием необходимого класса для таблицы. Реализация static в JS позволяет обращаться к static свойствам и методам наследующего класса из базового класса что позовлило внедрить в базовый класс TypedData все необходимые методы. 

### Вызов метода начальной инициализации класса initTableDef 
Для осуществления начальной начальной инициализации static объекта refMetaData необходимо обязательно вызывать метод initTableDef после описания класса. Вызов метода приводит к формированию необходимых метаданных для таблицы, формированию строк YQL запросов.
```js
Tdef.initTableDef(Tdef, 'tmdb', databaseName, tdef);
```
Где:  

|Параметр|Описание   |
|---|---|
|Tdef |название класса в котором Вы описали таблицу|
|'tmdb'|название таблицы в базе данных YDB|
|databaseName|значение, ранее сохраненное в поле DATABASENAME (например "/ru-central1/b1gib03pgvqrrfvhl3kb/etnn9li53arnjigll14s")  
|tdef|объект, описывающий структуру таблицы|  

Дополнительно добавлю что вызов метода начальной инициализации можно добавить в сецию static класса. Такая возможность добавлена в ES2022 и уже поддержана в TS 4.4.4
([см. документацию MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Class_static_initialization_blocks))

# Краткая информация по работе с SDK 

[В документации](https://cloud.yandex.ru/docs/ydb/ydb-sdk/)
Дается три понятия: **драйвер, клиент, сессия**.

## Драйвер
Драйвер YDB отвечает за взаимодействие приложения и YDB на транспортном уровне.
**Драйвер** должен существовать на всем протяжении жизненного цикла работы с YDB. Перед началом работы, необходимо инициализировать драйвер YDB.

В настоящем примере инициализация драйвера осуществляется функцией initYDBdriver в файле ydb-functions. 

Для подключения к базе данных необходимо передать авторизационную информацию.
Это можно сделать несколькими способами.
Все возможные способы описаны в [исходном коде SDK](https://github.com/ydb-platform/ydb-nodejs-sdk/blob/master/src/parse-env-vars.ts#L74)

Обратите внимание что часть способов уже deprecated.
Я выбрал наиболее простой способ авторизации в YDB - создал файл с ключами и дал ссылку на него в env.local переменной  
```YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS```

Создание файла с ключами описано в секции "Формирование ключа для доступа к YDB".

При создании драйвера также инициализируется логер.
Поскольку проект учебный - то в env.local добавлена переменная которая выводит максимум отладочной информации:  
YDB_SDK_LOGLEVEL=debug

## Клиент
Клиент отвечает за работу с сущностями YDB.

Самостоятельно клиент создавать не требуется (верно для nodejs SDK) - клиент создается самим драйвером в момент инициализации драйвера.

Драйвер инициализирует DiscoveryService, который опрашивает эндпойнты и связывает с каждым эндпойнтом фабрику сессий.

В рамках драйвера создаются **tableClient и schemeClient**, основная причина их разделения - это разные пулы сессий.

У каждого пула свой список используемых и свободных сессий, свои min/max-лимиты. При порождении новой сессии в рамках пула (сессия порождается, если все имеющиеся сессии заняты, но мы еще не вышли за пределы max-лимита на данный пул) по очереди обходятся все известные эндпойнты которые нам вернул DiscoveryService), т.е. запрос 1 на порождение сессии получит ее из эндпойнта1, а запрос 2 получит новую сессию из эндпойнта 2 - это простейший механизм балансировки сессий.

## Сессия
Сессия содержит информацию о выполняемых транзакциях и подготовленных запросах.

Получать сессию необходимо через клиента путем вызова метода<br>
 driver.tableClient.withSession  
либо  
 driver.tableClient.withSessionRetry

единственное отличие этих методов - это параметр maxRetries, который присутствует во втором методе.

При наличии параметра maxRetries служебный метод _withSession пробует исполнить запрос еще раз не более maxRetries раз с другой сессией.

Следует отметить, что автор SDK - Timur Sufiev использует первый способ - withSession.
При этом вызов самого запроса оборачивает в withRetries.

## Ретраи

При создании базы YDB (или потом) может быть установлено ограничение по пропускной способности, RU/с, которое ограничивает максимальное начисление платы за пользование serverless YDB за 1 секунду. В случае большой нагрузки на YDB при обработке запрос может прийти отказ из за превышения лимита начисления.

Поскольку это стандартная ситуация - то предусмотрены механизмы повторения отправленного запроса.  

withSessionRetry повторяет запрос только при получении двух ошибок: BadSession и SessionBusy.

Второй способ сделать повтор запроса - обернуть метод класса в декоратор  @retryable

Третий способ повторения запроса - использование функции-обертки withRetries.

withRetries формирует необходимые параметры и вызвает метод RetryStrategy.retry.

RetryStrategy.retry не пересоздает сессию в случае ошибок
RetryStrategy.retry делает ретраи на errors.Unavailable, errors.Aborted, errors.NotFound и errors.Overloaded 






# Устнавливаем подключение к Serverless YDB








# Таймауты 
// Indicates that client is no longer interested in the result of operation after the specified duration
// starting from the time operation arrives at the server.
// Server will try to stop the execution of operation and if no result is currently available the operation
// will receive TIMEOUT status code, which will be sent back to client if it was waiting for the operation result.
// Timeout of operation does not tell anything about its result, it might be completed successfully
// or cancelled on server.
google.protobuf.Duration operation_timeout = 2;

    // Server will try to cancel the operation after the specified duration starting from the time
    // the operation arrives at server.
    // In case of successful cancellation operation will receive CANCELLED status code, which will be
    // sent back to client if it was waiting for the operation result.
    // In case when cancellation isn't possible, no action will be performed.
    google.protobuf.Duration cancel_after = 3;

Проверка прилинкованных пакетов
npm ls -g --depth=0 --link=true
npm ls --depth=0 --link=true